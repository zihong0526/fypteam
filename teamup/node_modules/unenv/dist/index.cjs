'use strict';

const node_module = require('node:module');
const mlly = require('mlly');

const NodeBuiltinModules = [].concat(
  node_module.Module.builtinModules,
  [
    "assert/strict",
    "fs/promises",
    "path/posix",
    "path/win32",
    "stream/consumers",
    "stream/promises",
    "stream/web",
    "timers/promises",
    "util/types"
  ]
);
function mapArrToVal(val, arr) {
  return Object.fromEntries(arr.map((c) => [c, val]));
}

const version = "2.0.0-20241218-183400-5d6aec3";

const node = {
  meta: {
    name: "unenv:node",
    version
  },
  alias: {
    "node-fetch": "unenv/runtime/npm/node-fetch",
    "cross-fetch": "unenv/runtime/npm/cross-fetch",
    "cross-fetch/polyfill": "unenv/runtime/mock/empty",
    "isomorphic-fetch": "unenv/runtime/mock/empty"
  },
  polyfill: [],
  external: [...NodeBuiltinModules]
};

const nodeless = {
  meta: {
    name: "unenv:nodeless",
    version
  },
  alias: {
    // Generic mock for built-ins
    ...mapArrToVal("unenv/runtime/mock/proxy-cjs", NodeBuiltinModules),
    // Built-ins implemented by unenv
    "buffer/index.js": "buffer",
    ...Object.fromEntries(
      [
        "assert",
        "assert/strict",
        "async_hooks",
        "buffer",
        "console",
        "child_process",
        "constants",
        "cluster",
        "crypto",
        "dgram",
        "diagnostics_channel",
        "dns",
        "dns/promises",
        "domain",
        "events",
        "fs",
        "fs/promises",
        "http",
        "https",
        "http2",
        "inspector",
        "module",
        "net",
        "os",
        "path",
        "punycode",
        "perf_hooks",
        "process",
        "querystring",
        "readline",
        "readline/promises",
        "stream",
        "stream/promises",
        "stream/consumers",
        "stream/web",
        "string_decoder",
        "trace_events",
        "timers",
        "timers/promises",
        "tls",
        "tty",
        "url",
        "util",
        "util/types",
        "v8",
        "vm",
        "wasi",
        "worker_threads",
        "zlib"
      ].map((m) => [m, `unenv/runtime/node/${m}/index`])
    ),
    "path/posix": "unenv/runtime/node/path/index",
    "path/win32": "unenv/runtime/node/path/index",
    "inspector/promises": "unenv/runtime/node/inspector/index",
    // The sys module is deprecated and has been renamed util
    // https://github.com/nodejs/node/blob/main/lib/sys.js#L27
    sys: "unenv/runtime/node/util/index",
    // npm
    fsevents: "unenv/runtime/npm/fsevents",
    "node-fetch": "unenv/runtime/npm/node-fetch",
    "node-fetch-native": "unenv/runtime/npm/node-fetch",
    "node-fetch-native/polyfill": "unenv/runtime/mock/empty",
    "cross-fetch": "unenv/runtime/npm/cross-fetch",
    "cross-fetch/polyfill": "unenv/runtime/mock/empty",
    "isomorphic-fetch": "unenv/runtime/mock/empty",
    inherits: "unenv/runtime/npm/inherits"
  },
  inject: {
    global: "unenv/runtime/node/_global",
    process: "unenv/runtime/node/process/index",
    Buffer: ["unenv/runtime/node/buffer/index", "Buffer"],
    performance: "unenv/runtime/polyfill/performance"
  },
  polyfill: [
    "unenv/runtime/polyfill/node-global",
    "unenv/runtime/polyfill/process",
    "unenv/runtime/polyfill/performance"
  ]
};
for (const m of NodeBuiltinModules) {
  nodeless.alias[`node:${m}`] = nodeless.alias[m];
}
const nodeCompatPreset = nodeless;

const cloudflareNodeCompatModules = [
  "_stream_duplex",
  "_stream_passthrough",
  "_stream_readable",
  "_stream_transform",
  "_stream_writable",
  "assert",
  "assert/strict",
  "buffer",
  "diagnostics_channel",
  "dns",
  "dns/promises",
  "events",
  "path",
  "path/posix",
  "path/win32",
  "querystring",
  "stream",
  "stream/consumers",
  "stream/promises",
  "stream/web",
  "string_decoder",
  "url",
  "util/types",
  "zlib"
];
const hybridNodeCompatModules = [
  "async_hooks",
  "console",
  "crypto",
  "module",
  "process",
  "timers",
  "util"
];
const cloudflarePreset = {
  meta: {
    name: "unenv:cloudflare",
    version
  },
  alias: {
    ...Object.fromEntries(
      cloudflareNodeCompatModules.flatMap((p) => [
        [p, p],
        [`node:${p}`, `node:${p}`]
      ])
    ),
    // The `node:sys` module is just a deprecated alias for `node:util`
    // Keep this until util is a full compat module.
    sys: "unenv/runtime/node/util/$cloudflare",
    "node:sys": "unenv/runtime/node/util/$cloudflare",
    // define aliases for hybrid modules
    ...Object.fromEntries(
      hybridNodeCompatModules.flatMap((m) => [
        [m, `unenv/runtime/node/${m}/$cloudflare`],
        [`node:${m}`, `unenv/runtime/node/${m}/$cloudflare`]
      ])
    ),
    // TODO: this is a hotfix and breaks unenv/fetch
    // https://github.com/unjs/unenv/issues/364
    "unenv/runtime/node/stream/index": "node:stream"
  },
  inject: {
    // workerd already defines `global` and `Buffer`
    // override the previous presets so that we use the native implementation
    Buffer: false,
    global: false,
    console: "unenv/runtime/node/console/$cloudflare",
    process: "unenv/runtime/node/process/$cloudflare",
    setImmediate: ["unenv/runtime/node/timers/$cloudflare", "setImmediate"],
    clearImmediate: ["unenv/runtime/node/timers/$cloudflare", "clearImmediate"]
  },
  polyfill: [],
  external: cloudflareNodeCompatModules.flatMap((p) => [p, `node:${p}`])
};
const cloudflarePreset$1 = cloudflarePreset;

function defineEnv(opts = {}) {
  const presets = [];
  if (opts.nodeCompat) {
    presets.push(nodeCompatPreset);
  }
  if (opts.presets) {
    presets.push(...opts.presets);
  }
  if (opts.overrides) {
    presets.push(opts.overrides);
  }
  const resolvedEnv = env(...presets);
  if (opts.resolve) {
    const resolvePaths = [
      ...opts.resolve === true ? [] : opts.resolve.paths || [],
      ...presets.map((preset) => preset.meta?.url).filter(Boolean),
      __filename
      // unenv
    ];
    const resolveOpts = {
      url: resolvePaths
    };
    const _tryResolve = (id) => {
      try {
        return mlly.resolvePathSync(id, resolveOpts);
      } catch {
      }
    };
    const _resolve = (id) => {
      let resolved = _tryResolve(id);
      if (!resolved && id.startsWith("unenv/")) {
        resolved = _tryResolve(id.replace("unenv/", "unenv-nightly/"));
      }
      return resolved || id;
    };
    for (const alias in resolvedEnv.alias) {
      resolvedEnv.alias[alias] = _resolve(resolvedEnv.alias[alias]);
    }
    for (let i = 0; i < resolvedEnv.polyfill.length; i++) {
      resolvedEnv.polyfill[i] = _resolve(resolvedEnv.polyfill[i]);
    }
    for (const global in resolvedEnv.inject) {
      const inject = resolvedEnv.inject[global];
      if (Array.isArray(inject)) {
        const [id, ...path] = inject;
        resolvedEnv.inject[global] = [_resolve(id), ...path];
      } else {
        resolvedEnv.inject[global] = _resolve(inject);
      }
    }
  }
  return { env: resolvedEnv, presets };
}
function env(...presets) {
  const _env = {
    alias: {},
    inject: {},
    polyfill: [],
    external: []
  };
  for (const preset of presets) {
    if (preset.alias) {
      const aliases = Object.keys(preset.alias).sort(
        (a, b) => b.split("/").length - a.split("/").length || b.length - a.length
      );
      for (const from of aliases) {
        _env.alias[from] = preset.alias[from];
      }
    }
    if (preset.inject) {
      for (const global in preset.inject) {
        const globalValue = preset.inject[global];
        if (Array.isArray(globalValue)) {
          const [id, ...path] = globalValue;
          _env.inject[global] = [id, ...path];
        } else if (globalValue === false) {
          delete _env.inject[global];
        } else {
          _env.inject[global] = globalValue;
        }
      }
    }
    if (preset.polyfill) {
      _env.polyfill.push(...preset.polyfill.filter(Boolean));
    }
    if (preset.external) {
      _env.external.push(...preset.external);
    }
  }
  return _env;
}

exports.NodeBuiltinModules = NodeBuiltinModules;
exports.cloudflare = cloudflarePreset$1;
exports.defineEnv = defineEnv;
exports.env = env;
exports.mapArrToVal = mapArrToVal;
exports.node = node;
exports.nodeless = nodeCompatPreset;
